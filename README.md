# CSharpDSAGames

A terminal-based C# project designed to showcase fundamental understanding of **Data Structures**, **Algorithms**, and their application in **game-inspired mini projects**. Built for developers looking to solidify their knowledge and impress technical reviewers, especially in **game development studios**.

---

## ğŸ¯ Project Goals

- âœ… Master core C# concepts outside of Unity
- âœ… Implement foundational **DSA (Data Structures & Algorithms)**
- âœ… Build interactive **console games** using algorithmic logic
- âœ… Showcase clean code and problem-solving in a developer-friendly repo

---

## ğŸ“ Structure

```bash
CSharpDSAGames/
â”œâ”€â”€ DataStructures/     # Stacks, Queues, Lists, Trees, etc.
â”œâ”€â”€ Algorithms/         # Sorting, Searching, Recursion, etc.
â”œâ”€â”€ Games/              # Terminal-based games using DS/A logic
â”œâ”€â”€ Program.cs          # Entry point with menu interface
â”œâ”€â”€ README.md           # This file
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ ISSUE_TEMPLATES/  # Tasks for GitHub Issues
```

---

## ğŸš€ Getting Started

### Run the project:

```bash
cd CSharpDSAGames
 dotnet run
```

> Requires [.NET 6 SDK+](https://dotnet.microsoft.com/en-us/download) installed.

### Menu:

```
Welcome to CSharpDSAGames!

1. Data Structures
2. Algorithms
3. Games
4. Exit
```

---

## ğŸ§  Modules Overview

### Data Structures

> âœ… = Complete | ğŸ”„ = In Progress | ğŸ“ = Planned

| Structure          | Status | Description |
|--------------------|--------|-------------|
| Stack              | âœ… | Data structure that follows the **LIFO** principle (Last In First Out), used for undo systems, backtracking, parsing. |
| Queue              | âœ… | Data structure that follows the **FIFO** principle (First In First Out), used for task scheduling, turn management, real-time systems. |
| Linked List        | ğŸ”„ | A linear collection where each element (node) points to the next; allows efficient insertions and deletions anywhere. |
| Doubly Linked List | ğŸ“ | A linked list where each node points both to the next and the previous node, enabling efficient two-way traversal. |
| Trees              | ğŸ“ | A hierarchical structure where each node has children, used for representing relationships like filesystems, decision trees, and scene graphs. |
| Graphs             | ğŸ“ | A flexible collection of nodes connected by edges; models complex networks like maps, quests, and AI behavior. |
| Heaps              | ğŸ“ | A special binary tree that maintains a specific order (min-heap or max-heap); used for efficient priority scheduling and pathfinding. |
| Tries              | ğŸ“ | A tree-like data structure that stores strings by character; optimized for fast word lookup, autocomplete, and spell-checking. |

### Algorithms
> âœ… = Complete | ğŸ”„ = In Progress | ğŸ“ = Planned

| Algorithm           | Status | Description |
|---------------------|--------|-------------|
| Linear Search       | ğŸ”„ | Simple scan through elements to find a match (no sorting required). |
| Binary Search       | ğŸ“ | Efficient search on sorted arrays, repeatedly dividing search space by half. |
| Bubble Sort         | ğŸ“ | Simple sorting algorithm that repeatedly swaps adjacent elements if out of order. |
| Insertion Sort      | ğŸ“ | Builds a sorted array one element at a time by inserting into the correct position. |
| Selection Sort      | ğŸ“ | Repeatedly selects the minimum (or maximum) element and places it at the correct position. |
| Merge Sort          | ğŸ“ | Divide-and-conquer sorting algorithm that splits arrays and merges them back sorted. |
| Quick Sort          | ğŸ“ | Divide-and-conquer sorting that selects a pivot and partitions elements around it. |
| Recursion Basics    | ğŸ“ | Writing functions that call themselves; core for divide-and-conquer problems. |
| Depth-First Search (DFS) | ğŸ“ | Traverses trees or graphs deeply before backtracking; typically implemented with recursion or a stack. |
| Breadth-First Search (BFS) | ğŸ“ | Traverses trees or graphs level by level; typically implemented with a queue. |
| Dijkstra's Algorithm | ğŸ“ | Finds the shortest path between nodes in a graph with non-negative edge weights. |
| A* Pathfinding      | ğŸ“ | Optimized shortest path algorithm using heuristics; widely used in games for AI navigation. |

-

### Games

- Stack Games: 
  - Stack Room Escape
  - Stack RPG Battle
- Queue Games:
  - Queue Boss Rush

---

---

## ğŸ“ License

MIT

